\newcommand{\ttinterp}[1]{\mathcal{E}\interp{#1}}

\section{Elaborating \Idris{}}

An \Idris{} program consists of a series of declarations --- data types, functions,
type classes and instances. In this section, we describe how these high level declarations
are translated into a \TT{} program consisting of inductive families and pattern matching
function definitions. We will need to work at the \remph{declaration} level, and at
the \remph{expression} level, defining the following meta-operations:

\begin{itemize}
\item $\ttinterp{\cdot}$, which builds a \TT{} expression from an \Idris{} expression
\item $\MO{Elab}$, which processes a top level \Idris{} declaration by generating
one or more \TT{} declarations.
\end{itemize}

\subsection{The Development Calculus \TTdev}

We build \TT{} expressions by using high level \Idris{} expressions to
direct a tactic based theorem prover, which builds the \TT{} expressions
step by step, by refinement. In order to build expressions in this way,
the type theory needs to support
\remph{incomplete} terms, and a method for term construction. 
To achieve this, we extend \TT{} with \remph{holes},
calling the extended calculus \TTdev{}.
Holes stand for the parts of programs which have not yet been
instantiated; this largely follows the \Oleg{} development
calculus~\cite{McBride1999}.

The basic idea is to extend the syntax for binders with a \remph{hole}
binding and a \remph{guess} binding. 
These extensions are given in Figure \ref{ttdev}.
The \remph{guess} binding is
similar to a $\LET$ binding, but without any computational force,
i.e. the bound names do not reduce.
Using binders to represent holes is useful in a dependently typed setting since
one value may determine another. Attaching a ``guess'' to a binder ensures that
instantiating one such value also instantiates all of its dependencies. The
typing rules for binders ensure that no $?$ bindings leak into types.

\FFIG{
\AR{
\vb ::= \ldots 
 \:\mid\: \hole{\vx}{\vt} \:\:(\mbox{hole binding}) \:\:
 \:\mid\: \guess{\vx}{\vt}{\vt} \:\:(\mbox{guess})
\medskip\\
\Rule{
\Gamma;\hole{\vx}{\vS}\proves\ve\Hab\vT
}
{
\Gamma\proves\hole{\vx}{\vS}\SC\ve\Hab\vT
}
\hspace*{0.1cm}\vx\not\in\vT
\hspace*{0.1in}\mathsf{Hole}
\hg
\Rule{
\Gamma;\guess{\vx}{\vS}{\ve_1}\proves\ve_2\Hab\vT
}
{
\Gamma\proves\guess{\vx}{\vS}{\ve_1}\SC\ve_2\Hab\vT
}
\hspace*{0.1cm}\vx\not\in\vT
\hspace*{0.1in}\mathsf{Guess}
}
}
{\TTdev{} extensions}
{ttdev}


\subsection{Proof State}

A proof state is a tuple, $(\vC, \Delta, \vT, \vQ)$, containing:

\begin{itemize}
\item A global context, $\vC$, containing pattern matching definitions
\item A local context, $\Delta$, containing pattern bindings
\item A proof term, $\vT$, in \TTdev{}
\item A hole queue, $\vQ$
%\item \remph{Deferred} definitions, $\vD$, for introducing global metavariables
\end{itemize}

The \remph{hole queue} is a list of names of hole and guess binders in the proof term ---
we ensure that each bound name is unique. Holes essentially refer to \remph{sub goals}
in the proof.
When this queue is empty, the proof term is complete.
Creating a \TT{} expression from an \Idris{} expresson involves creating
a new proof state, with an empty proof term, and using the high level definition
to direct the building of a final proof state, with a complete proof term.

In the implementation, the proof state is captured in an elaboration monad,
\texttt{Elab}, which includes various operations for querying and updating
the proof state, manipulating terms, generating fresh names, etc. However, we will
describe \Idris{} elaboration in terms of meta-operations on the proof state,
in order to capture the essence of the elaboration process without being distracted
by implementation details. These meta-operations include: 

\begin{itemize}
\item \demph{Queries} which retrieve values from the proof state, without modifying
the state. For example, we can:
\begin{itemize}
\item Get the type of the current sub goal
\item Retrieve the local context $\Gamma$ at the current sub goal
\item Type check or normalise a term relative to $\Gamma$
\end{itemize}
\item \demph{Unification}, which unifies two terms (potentially solving sub goals) 
relative to $\Gamma$
\item \demph{Tactics} which update the proof term. Tactics operate on the sub term
at the binder specified by the head of the hole queue $\vQ$.
\item \demph{Focussing} on a specific sub goal, which brings a different sub goal to the
head of the hole queue.
%\item \demph{Deferring} a sub goal, which adds a new definition to the global context
%$\vC$ which solves the sub goal.
\end{itemize}

Elaboration of an \Idris{} expression involves creating a new proof state, running
a series of tactics to build a complete proof term, then retrieving and \remph{rechecking}
the final proof term, which must be a \TT{} program (i.e. does not contain any of the
\TTdev{} extensions).

\subsection{System State}

The system state is a tuple, $(\vC,\vA,\vI)$, containing:

\begin{itemize}
\item A global context, $\vC$, containing pattern matching definitions
\item Implicit arguments, $\vA$, recording which arguments are implicit for each global name
\item Type class instances, $\vI$, containing dictionaries for type classes
\end{itemize}

In the implementation, the system state is captured in a monad, \texttt{Idris}, and
includes additional information such as syntax overloadings,
command line options, and optimisations, which do not concern us here. Elaboration
of expressions requires access to the system state in particular in order to expand
implicit arguments and resolve type classes. 

For each global name, $\vA$ records whether its arguments are explicit, implicit,
or type class constraints.  For example, recall the declaration
of \texttt{vAdd}:

\begin{SaveVerbatim}{vAddImpT}

vAdd : Num a => Vect a n -> Vect a n -> Vect a n

\end{SaveVerbatim}
\useverb{vAddImpT} 

\noindent
Written in full, and giving each argument an explicit name, we get the
type declaration:

\begin{SaveVerbatim}{vAddImpT}

vAdd : (a : _) -> (n : _) -> (c : Num a) -> 
       (xs : Vect a n) -> (ys : Vect a n) -> Vect a n

\end{SaveVerbatim}
\useverb{vAddImpT} 

\noindent
For \tFN{vAdd}, we record that \texttt{a} and \texttt{n} are implicit, 
\texttt{c} is a constraint, and \texttt{xs} and \texttt{ys} are explicit. When
the elaborator encounters an application of \tFN{vAdd}, it knows that unless these arguments
are given explicitly, the application must be expanded.

\newcommand{\Check}{\MO{Check}_\Gamma}
\newcommand{\Eval}{\MO{Normalise}_\Gamma}
\newcommand{\Unify}{\MO{Unify}_\Gamma}

\subsection{Tactics}

% Meta-operations Check, Normalise, Unify 
In order to build \TT{} expressions from \Idris{} programs, we define a collection
of meta-operations for querying and modifying the proof state. Meta-operations
may have side-effects including failure, or updating the proof state. We have the following
primitive meta-operations:

\begin{itemize}
\item $\MO{Focus}\:\vn$, which moves $\vn$ to the head of the hole queue
\item $\MO{Check}$, which type checks an expression relative to a context
$\Gamma$. \\
$\Check\:\ve\:\mq\:(\vv,\vt)$ means that checking an expression $\ve$
returns a well typed value $\vv$ and its type $\vt$. $\MO{Check}$ will fail
if the expression is not well-typed.
\item $\MO{Normalise}$, which evaluates a well-typed expression relative to a context 
$\Gamma$.\\
$\Eval\:\ve\:\mq\:\vv$ means that evaluating the expression $\ve$ returns the
value $\vv$.
\item $\MO{Unify}$, which unifies two well-typed expressions.
\\
$\Unify\:\ve_1\:\ve_2\:\mq\:\tu$ means that unifying $\ve_1$ and $\ve_2$ produces a
mapping $\tu$ from hole names to the values the holes must be instantiated with for
$\ve_1$ and $\ve_2$ to be convertible relative to $\Gamma$ 
(i.e. for $\Gamma\proves\ve_1\converts\ve_2$ to hold). $\MO{Unify}$ will fail
if it cannot find such a mapping.
\end{itemize}

\remph{Tactics} are specifically meta-operations which operate on the sub-term given
by the hole at the head of the hole queue in the proof state. They take the following form:

\DM{
\PA{\A\A}{
\MO{Tactic}_\Gamma & \vec{\VV{args}} & \vt & \MoRet{\vt'}
}
}

A tactic takes a sequence of zero or more arguments $\vec{\VV{args}}$ followed by the sub-term $\vt$
on which it is operating. It runs relative to a context $\Gamma$ which contains all the bindings
and pattern bindings
in scope at that point in the term. The sub-term $\vt$ will either be a hole binding 
$\hole{\vx}{\vT}\SC\ve$ or a guess binding $\guess{\vx}{\vT}{\vv}\SC\ve$. The tactic returns a 
new term $\vt'$ which can take any form, provided it is well-typed. Tactics are executed by a higher
level meta-operation $\MO{RunTac}$, which locates the appropriate sub-term, replaces it with the
term returns by the tactic, updates the hole queue in the proof state, and updates holes which
have been solved by unification.

Creating and destroying holes: Claim, Fill, Solve

\DM{
\PA{\A\A}{
\MO{Claim}_\Gamma & (\vy \Hab\vS) & (\hole{\vx}{\vT}\SC\ve) & 
   \MoRet{\hole{\vx}{\vT}\SC\hole{\vy}{\vS}\SC\ve} \\
}
}

\DM{
\PA{\A\A}{
\MO{Fill}_\Gamma & \vv & (\hole{\vx}{\vT}\SC\ve) & 
   \MoRet{\RW{do}\:\AR{
   (\vv',\vT') \leftarrow \Check\:\vv\\
   \Unify\:\vT\:\vT'\\
   \RW{return}\:\guess{\vx}{\vT}{\vv'}\SC\SC\ve}
   } \\
}
}

\DM{
\PA{\A}{
\MO{Solve}_\Gamma & (\guess{\vx}{\vT}{\vv}\SC\ve) &
   \MoRet{\ve[\vv/\vx]}
}
}

Attack, Lambda, Pi, Let

Apply


%--- give unify in full, esp. as it solves sub goals? Maybe...

% Unify' G x t             = Success (x, t) if ?x : t in G
% Unify' G t x             = Success (x, t) if ?x : t in G
% Unify' G (b x. e) (b' x'. e')   = Unify' G b b'; Unify' G;b e e'[x/x']
% Unify' G ((\x.e) x) e'   = Unify' G e e' 
% Unify' G e ((\x.e') x)   = Unify' G e e' 
% Unify' G (f es) (f' es') = vs <- Unify' G f f'; Injective f
                             
% Unify' G x y             = Success () if G |- x == y
% Unify' G . .             = Failure

% Unify' G (\x : t . e) (\x : t' . e') = Unify' G t t'; Unify' G e e'
% ...


%\DM{
%}

\subsection{Elaborating Expressions}


\IdrisM{}, a subset of \Idris{} not including syntactic sugar (e.g. pairs, do notation, etc).

Implicit and type class arguments? Expanded at the application site (we need to know
it's the global name after all and we do that by type).

\subsection{Elaborating Data Types}

\subsection{Elaborating Pattern Matching}

