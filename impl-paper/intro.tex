\section{Introduction}

Dependently typed programming languages, such as Agda \cite{norell2007thesis}
and Coq \cite{Bertot2004}, have emerged in recent years as a promising approach
to ensuring the correctness of software. The \Idris{} language
\cite{Brady2011a} aims to take these ideas further, and provide support for
verification of general-purpose systems software. In contrast to Agda and Coq,
which have arisen from the theorem proving community, \Idris{} takes Haskell as
its baseline.  Recent Haskell extensions such as GADTs and type families have
given some of the power of dependent types to Haskell programmers. However,
these extensions are inherently limited in that they are required to maintain
backwards compatibility with existing Haskell programs.  \Idris{}, being a new
language, has no such limitation, essentially asking the question:

\begin{center}
\emph{``What if Haskell had \emph{full} dependent types?''}
\end{center}

It is important, for the sake of usability of a programming language, to provide
a programming notation which allows programmers to express high level concepts
in a natural way. Taking Haskell as a starting point means that \Idris{} offers
high level structures such as type classes, \texttt{do}-notation, primitive types
and monadic I/O, for example.
Nevertheless, it is important for the sake of correctness of the language implementation
to have a small core language with well understood meta-theory
\cite{Altenkirch2010}.

How can we achieve both of these goals?

This paper describes a method for elaborating a high level dependently
typed functional programming language to a low level core
language based on dependent type theory.
The method involves building an Embedded Domain Specific Language (EDSL) for constructing
programs in the core language, directed by high level program syntax. 
This method allows higher level language constructs to be constructed in a straightforward
manner.


\subsection{Contributions}

\begin{itemize}
\item Type checking dependent types~\cite{Chapman2005epigram,loh2010tutorial} is just one component
 of a language. There is folklore about what to do to turn it into a language. This
 paper aims to help language implementers avoid working things out for themselves.
\item What's the difference between a theorem prover and a practical systems programming
 language? Not much...
\end{itemize}

Also note --- to be an expert user of a language requires good understanding of the internals.

\subsection{Typographical conventions}

We'll have \Idris{} programs, \TT{} programs and meta-operations (standing for
Haskell programs which operate on \Idris{} or \TT{} programs). Suggestion:
\Idris{} always in \texttt{texttt}, with \texttt{e$_i$} standing for
non-terminal expressions.  \TT{} in mathematical notation, with names arising
from \Idris{} programs in \texttt{texttt}, and meta-operation
names either in \textsc{TextSC} or as $\interp{\cdot}$.

Also we will show some interactions at the \texttt{Idris>} prompt, which can be identified
by the prompt.
