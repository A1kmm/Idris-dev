\section{Introduction}

This paper documents a new implementation of \Idris{}~\cite{Brady2011a}, in which
I attempt to learn from the mistakes of the previous implementation and make
it nice and clean and solid. Maybe I'll keep it up to date as I write the
code.

The title is deliberately a reordering of the words in my thesis
title~\cite{Brady2005}. Whereas that was about taking elaborated programs
in the core type theory of \Epigram{}~\cite{McBride2004a} and compiling them
efficiently (i.e. making the language implementation practical) this paper is
about making the language itself practical. 

\subsection{Some Goals}

\begin{itemize}
\item Type checking dependent types~\cite{Chapman2005epigram,loh2010tutorial} is just one component
 of a language. There is folklore about what to do to turn it into a language. This
 paper aims to help language implementers avoid working things out for themselves.
\item What's the difference between a theorem prover and a practical systems programming
 language? Not much...
\end{itemize}

Also note --- to be an expert user of a language requires good understanding of the internals.

\subsection{Typographical conventions}

We'll have \Idris{} programs, \TT{} programs and meta-operations (standing for
Haskell programs which operate on \Idris{} or \TT{} programs). Suggestion:
\Idris{} always in \texttt{texttt}, with \texttt{e$_i$} standing for
non-terminal expressions.  \TT{} in mathematical notation, with names arising
from \Idris{} programs in \texttt{texttt}, and meta-operation
names either in \textsc{TextSC} or as $\interp{\cdot}$.

Also we will show some interactions at the \texttt{Idris>} prompt, which can be identified
by the prompt.
